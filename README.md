И старт и саве принимают такой json я бы хотел чтобы оба записывали регнамбер в regnum  "regData": {
      "userCode": "b.shymkentbay",
      "userName": "Шымкентбай Бақытжан Бахтиярұлы",
      "departmentId": "19.100512",
      "departmentName": "Управление разработки пенсионного учета",
      "startdate": "2025-08-05T10:09:46.584Z",
      "regnum": ""
    }, именно сюда  "regnum": "" и потом отсюда будет проверять думаю правильно {
  "processCode": "Memo",
  "initiatorCode": "m.ilespayev",
  "initiatorName": "Илеспаев",
  "payload": {
    "regData": {
      "userCode": "b.shymkentbay",
      "userName": "Шымкентбай Бақытжан Бахтиярұлы",
      "departmentId": "19.100512",
      "departmentName": "Управление разработки пенсионного учета",
      "startdate": "2025-08-05T10:09:46.584Z",
      "regnum": ""
    },
    "sysInfo": {
      "userCode": "b.shymkentbay",
      "userName": "Шымкентбай Бақытжан Бахтиярұлы",
      "comment": "comment",
      "action": "submit",
      "condition": "string"
    },
    "initiator": {
      "id": 7820,
      "name": "Шымкентбай Бақытжан Бахтиярұлы",
      "position": "Главный специалист",
      "login": "b.shymkentbay",
      "statusCode": 6,
      "statusDescription": "Работа",
      "depId": "19.100512",
      "depName": "Управление разработки пенсионного учета",
      "parentDepId": "19.100500",
      "parentDepName": "Департамент цифровизации",
      "isFilial": false,
      "mail": "b.shymkentbay@enpf.kz",
      "localPhone": "0",
      "mobilePhone": "+7(708) 927-44-98",
      "isManager": false,
      "managerTabNumber": "4340",
      "disabled": false,
      "tabNumber": "00ЗП-00292"
    },
    "approvers": [
      {
        "loginAD": "m.ilespayev",
        "id": 611,
        "name": "Илеспаев Меииржан Анварович",
        "shortName": null,
        "position": "Заместитель директора департамента",
        "login": "m.ilespayev",
        "statusCode": 6,
        "statusDescription": "Работа",
        "depId": "19.100500",
        "depName": "Департамент цифровизации",
        "parentDepId": "19.100500",
        "parentDepName": "Департамент цифровизации",
        "isFilial": false,
        "mail": "m.ilespayev@enpf.kz",
        "localPhone": "0",
        "mobilePhone": "+7(702) 171-71-14",
        "isManager": true,
        "managerTabNumber": "4303",
        "disabled": false,
        "tabNumber": "00ЗП-00240",
        "order": 1
      },
      {
        "loginAD": "a.ysmail",
        "id": 1545,
        "name": "Ысмаил Арғынбек Байдабекұлы",
        "shortName": null,
        "position": "Главный специалист",
        "login": "a.ysmail",
        "statusCode": 6,
        "statusDescription": "Работа",
        "depId": "19.100508",
        "depName": "Управление разработки фронтальных систем",
        "parentDepId": "19.100500",
        "parentDepName": "Департамент цифровизации",
        "isFilial": false,
        "mail": "a.ysmail@enpf.kz",
        "localPhone": "0",
        "mobilePhone": "+7(702) 778-53-30",
        "isManager": false,
        "managerTabNumber": "4340",
        "disabled": false,
        "tabNumber": "00ЗП-00289",
        "order": 2
      },
      {
        "loginAD": "i.dogali",
        "id": 611,
        "name": "Илеспаев Меииржан Анварович",
        "shortName": null,
        "position": "Заместитель директора департамента",
        "login": "m.ilespayev",
        "statusCode": 6,
        "statusDescription": "Работа",
        "depId": "19.100500",
        "depName": "Департамент цифровизации",
        "parentDepId": "19.100500",
        "parentDepName": "Департамент цифровизации",
        "isFilial": false,
        "mail": "m.ilespayev@enpf.kz",
        "localPhone": "0",
        "mobilePhone": "+7(702) 171-71-14",
        "isManager": true,
        "managerTabNumber": "4303",
        "disabled": false,
        "tabNumber": "00ЗП-00240",
        "order": 3
      }
    ],
    "recipients": [
      {
        "loginAD": "l.iskender",
        "id": 633,
        "name": "Искендер Лесхан Муратұлы",
        "shortName": null,
        "position": "Главный специалист",
        "login": "l.iskender",
        "statusCode": 6,
        "statusDescription": "Работа",
        "depId": "19.100509",
        "depName": "Управление разработки Web приложений и сервисов",
        "parentDepId": "19.100500",
        "parentDepName": "Департамент цифровизации",
        "isFilial": false,
        "mail": "l.iskender@enpf.kz",
        "localPhone": "0",
        "mobilePhone": "+7(707) 517-04-67",
        "isManager": false,
        "managerTabNumber": "4340",
        "disabled": false,
        "tabNumber": "00ЗП-00083"
      },
      {
        "loginAD": "i.dosgali",
        "id": 414,
        "name": "Досгали Искандер Досгалиұлы",
        "shortName": null,
        "position": "Главный специалист",
        "login": "i.dosgali",
        "statusCode": 6,
        "statusDescription": "Работа",
        "depId": "19.100509",
        "depName": "Управление разработки Web приложений и сервисов",
        "parentDepId": "19.100500",
        "parentDepName": "Департамент цифровизации",
        "isFilial": false,
        "mail": "i.dosgali@enpf.kz",
        "localPhone": "0",
        "mobilePhone": "+7(747) 790-29-49",
        "isManager": false,
        "managerTabNumber": "4340",
        "disabled": false,
        "tabNumber": "00ЗП-00275"
      }
    ],
    "signer": {
      "loginAD": "a.aristombekov",
      "id": 168,
      "name": "Аристомбеков Арстан Рамазанулы",
      "shortName": null,
      "position": "Директор департамента",
      "login": "a.aristombekov",
      "statusCode": 5,
      "statusDescription": "Отпуск основной",
      "depId": "19.100500",
      "depName": "Департамент цифровизации",
      "parentDepId": "19.100500",
      "parentDepName": "Департамент цифровизации",
      "isFilial": false,
      "mail": "a.aristombekov@enpf.kz",
      "localPhone": "0",
      "mobilePhone": "+7(705) 950-90-65",
      "isManager": true,
      "managerTabNumber": "4303",
      "disabled": false,
      "tabNumber": "4340"
    },
    "processData": {
      "documentTitle": "тема документа",
      "approvalTypeCode": "Parallel",
      "approvalTypeName": "Параллельно",
      "nomenclatureId": "1",
      "nomenclatureName": "Акт",
      "documentLang": "ru",
      "confLevelCode": "string",
      "confLevelName": "string",
      "pageCount": "5",
      "allGroups": "string",
      "myGroups": "string",
      "DueDate": "date",
      "documentBody": "<p><strong>ТЕКС&nbsp;СЗ</strong></p>"
    },
    "files": [
      {
        "fileId": "0ec544b8-6d84-4fd5-93fc-ff22f13053b3",
        "fileName": "Рисковое событие.docx",
        "fileType": "scan"
      },
      {
        "fileId": "8d1b2532-b727-484d-877f-1e7658851a2e",
        "fileName": "ffh.pdf",
        "fileType": "scan"
      }
    ]
  }
} using BpmBaseApi.Domain.Entities.Event.Process;
using BpmBaseApi.Domain.Models;
using BpmBaseApi.Persistence.Interfaces;
using BpmBaseApi.Services.Interfaces;
using BpmBaseApi.Shared.Commands.Process;
using BpmBaseApi.Shared.Enum;
using BpmBaseApi.Shared.Models.Camunda;
using BpmBaseApi.Shared.Models.Process;
using BpmBaseApi.Shared.Responses.Process;
using MediatR;
using System.Text.Encodings.Web;
using System.Text.Json;
using System.Text.Json.Nodes;
using BpmBaseApi.Shared.Dtos;
using static BpmBaseApi.Shared.Models.Process.CommonData;

namespace BpmBaseApi.Application.CommandHandlers.Process
{
    public class StartProcessCommandHandler(
        IUnitOfWork unitOfWork,
        IPayloadReaderService payloadReader,
        IProcessTaskService helperService,
        ICamundaService camundaService)
        : IRequestHandler<StartProcessCommand, BaseResponseDto<StartProcessResponse>>
    {
        public async Task<BaseResponseDto<StartProcessResponse>> Handle(
            StartProcessCommand command,
            CancellationToken cancellationToken)
        {
            // 1) Процесс
            var process = await unitOfWork.ProcessRepository
                              .GetByFilterAsync(cancellationToken, p => p.ProcessCode == command.ProcessCode)
                          ?? throw new HandlerException($"Процесс с кодом {command.ProcessCode} не найден",
                              ErrorCodesEnum.Business);

            // 2) Готовим payload
            var jsonOptions = new JsonSerializerOptions { Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping };
            var payloadJson = JsonSerializer.Serialize(command.Payload, jsonOptions);

            var regData = payloadReader.ReadSection<RegData>(command.Payload, "regData");
            var processDataDto = payloadReader.ReadSection<ProcessDataDto>(command.Payload, "processData");
            var regNumberFromPayload = TryGetRegNumberFromPayload(payloadJson);

            // === A) Если в payload есть regNumber, пробуем использовать существующую заявку ===
            if (!string.IsNullOrWhiteSpace(regNumberFromPayload))
            {
                // 1) Если уже есть Started с этим regNumber — просто вернём его (idempotency)
                var alreadyStarted = await unitOfWork.ProcessDataRepository.GetByFilterAsync(
                    cancellationToken,
                    p => p.ProcessCode == process.ProcessCode
                         && p.RegNumber == regNumberFromPayload
                         && p.StatusCode == "Started"
                );
                if (alreadyStarted is not null)
                {
                    // можно (при желании) обновить payload/титул, но чаще лучше ничего не трогать
                    return new BaseResponseDto<StartProcessResponse>
                    {
                        Data = new StartProcessResponse
                            { ProcessGuid = alreadyStarted.Id, RegNumber = alreadyStarted.RegNumber }
                    };
                }

                // 2) Есть Draft — апдейтим его и стартуем
                var draft = await unitOfWork.ProcessDataRepository.GetByFilterAsync(
                    cancellationToken,
                    p => p.ProcessCode == process.ProcessCode
                         && p.RegNumber == regNumberFromPayload
                         && p.StatusCode == "Draft"
                );

                if (draft is not null)
                {
                    await unitOfWork.ProcessDataRepository.RaiseEvent(new ProcessDataEditedEvent
                    {
                        EntityId = draft.Id,
                        StatusCode = "Started",
                        StatusName = "В работе",
                        PayloadJson = payloadJson,
                        InitiatorCode = regData?.UserCode,
                        InitiatorName = regData?.UserName,
                        Title = processDataDto?.DocumentTitle ?? draft.Title
                    }, cancellationToken);

                    await StartCamundaAndLinkAsync(draft.Id, cancellationToken);

                    // files: upsert (только новые fileId)
                    await AddFilesUpsertAsync(draft.Id, payloadJson, cancellationToken);

                    // history: записываем Start только если его ещё нет
                    await WriteHistoryStartIfAbsentAsync(draft.Id, draft.RegNumber, payloadJson, cancellationToken);

                    return new BaseResponseDto<StartProcessResponse>
                    {
                        Data = new StartProcessResponse { ProcessGuid = draft.Id, RegNumber = draft.RegNumber }
                    };
                }
            }

            // === B) Черновика нет — создаём НОВУЮ заявку и стартуем (как раньше) ===
            // requestNumber генерим ТОЛЬКО здесь, чтобы не плодить «лишние» номера.
            var requestNumber = await helperService.GenerateRequestNumberAsync(command.ProcessCode, cancellationToken);

            var createdEvt = new ProcessDataCreatedEvent
            {
                ProcessId = process.Id,
                ProcessCode = process.ProcessCode,
                ProcessName = process.ProcessName,
                RegNumber = requestNumber,
                InitiatorCode = regData.UserCode,
                InitiatorName = regData.UserName,
                StatusCode = "Started",
                StatusName = "В работе",
                PayloadJson = payloadJson,
                Title = processDataDto.DocumentTitle
            };
            await unitOfWork.ProcessDataRepository.RaiseEvent(createdEvt, cancellationToken);

            await StartCamundaAndLinkAsync(createdEvt.EntityId, cancellationToken);
            await AddFilesUpsertAsync(createdEvt.EntityId, payloadJson, cancellationToken);
            await WriteHistoryStartIfAbsentAsync(createdEvt.EntityId, requestNumber, payloadJson, cancellationToken);

            return new BaseResponseDto<StartProcessResponse>
            {
                Data = new StartProcessResponse { ProcessGuid = createdEvt.EntityId, RegNumber = requestNumber }
            };

            // ---------- локальные функции ----------

            static string? TryGetRegNumberFromPayload(string payload)
            {
                try
                {
                    var root = JsonNode.Parse(payload)!.AsObject();
                    return root["regData"]?["regNumber"]?.GetValue<string>();
                }
                catch
                {
                    return null;
                }
            }

            async Task StartCamundaAndLinkAsync(Guid processDataId, CancellationToken ct)
            {
                var pi = await camundaService.CamundaStartProcess(new CamundaStartProcessRequest
                {
                    processCode = command.ProcessCode,
                    variables = new Dictionary<string, object> { { "processGuid", processDataId.ToString() } }
                });

                await unitOfWork.ProcessDataRepository.RaiseEvent(
                    new ProcessDataProcessInstanseIdChangedEvent
                    {
                        EntityId = processDataId,
                        ProcessInstanceId = pi
                    },
                    ct);
            }

            async Task AddFilesUpsertAsync(Guid processDataId, string payload, CancellationToken ct)
            {
                try
                {
                    var root = JsonNode.Parse(payload)!.AsObject();
                    var files = root["files"] as JsonArray;
                    if (files is null || files.Count == 0) return;

                    // вытащим уже существующие fileIds для этой заявки
                    var existing = await unitOfWork.ProcessFileRepository.GetByFilterListAsync(
                        ct,
                        f => f.ProcessDataId == processDataId
                    );
                    var existingIds = existing
                        .Where(x => x.FileId != Guid.Empty)
                        .Select(x => x.FileId)
                        .ToHashSet();

                    foreach (var node in files.OfType<JsonObject>())
                    {
                        var fileIdStr = node["fileId"]?.GetValue<string>();
                        var fileName = node["fileName"]?.GetValue<string>();
                        var fileType = node["fileType"]?.GetValue<string>();

                        if (string.IsNullOrWhiteSpace(fileName) || string.IsNullOrWhiteSpace(fileType))
                            throw new HandlerException(
                                "Каждый объект в \"files\" должен иметь непустые fileName и fileType",
                                ErrorCodesEnum.Business);
                        if (string.IsNullOrWhiteSpace(fileIdStr) || !Guid.TryParse(fileIdStr, out var fileId))
                            throw new HandlerException(
                                "Каждый объект в \"files\" должен иметь корректный GUID в поле fileId",
                                ErrorCodesEnum.Business);

                        // добавляем только новые fileId
                        if (existingIds.Contains(fileId)) continue;

                        await unitOfWork.ProcessFileRepository.RaiseEvent(new ProcessFileCreatedEvent
                        {
                            EntityId = Guid.NewGuid(),
                            ProcessDataId = processDataId,
                            FileId = fileId,
                            FileName = fileName,
                            FileType = fileType
                        }, ct);

                        existingIds.Add(fileId); // чтобы не вставить дважды из одного payload
                    }
                }
                catch
                {
                    // опционально: лог
                }
            }

            async Task WriteHistoryStartIfAbsentAsync(Guid processDataId, string regNumber, string payload,
                CancellationToken ct)
            {
                // если уже есть запись Start — не дублируем
                var hasStart = await unitOfWork.ProcessTaskHistoryRepository.CountAsync(
                    ct,
                    h => h.ProcessDataId == processDataId
                         && h.Action == ProcessAction.Start.ToString()
                );
                if (hasStart > 0) return;

                await unitOfWork.ProcessTaskHistoryRepository.RaiseEvent(new ProcessTaskHistoryCreatedEvent
                {
                    ProcessDataId = processDataId,
                    TaskId = processDataId,
                    Action = ProcessAction.Start.ToString(),
                    BlockName = "Регистрационная форма",
                    Timestamp = DateTime.Now,
                    PayloadJson = payload,
                    Comment = "",
                    Description = "",
                    ProcessCode = command.ProcessCode,
                    ProcessName = process.ProcessName,
                    RegNumber = regNumber,
                    InitiatorCode = regData.UserCode,
                    InitiatorName = regData.UserName,
                    Title = processDataDto.DocumentTitle
                }, ct);
            }
        }
    }
}

using System.Text.Encodings.Web;
using System.Text.Json;
using System.Text.Json.Nodes;
using BpmBaseApi.Domain.Entities.Event.Process;
using BpmBaseApi.Domain.Models;
using BpmBaseApi.Persistence.Interfaces;
using BpmBaseApi.Services.Interfaces;
using BpmBaseApi.Shared.Commands.Process;
using BpmBaseApi.Shared.Dtos;
using BpmBaseApi.Shared.Enum;
using BpmBaseApi.Shared.Models.Process;
using BpmBaseApi.Shared.Responses.Process;
using MediatR;
using static BpmBaseApi.Shared.Models.Process.CommonData;

namespace BpmBaseApi.Application.CommandHandlers.Process
{
    // Никакого ICamundaService тут нет
    public class SaveProcessCommandHandler(
        IUnitOfWork unitOfWork,
        IPayloadReaderService payloadReader,
        IProcessTaskService helperService   // используем для GenerateRequestNumberAsync
    ) : IRequestHandler<SaveProcessCommand, BaseResponseDto<StartProcessResponse>>
    {
        public async Task<BaseResponseDto<StartProcessResponse>> Handle(
            SaveProcessCommand command,
            CancellationToken cancellationToken)
        {
            // 1) Процесс должен существовать
            var process = await unitOfWork.ProcessRepository
                .GetByFilterAsync(cancellationToken, p => p.ProcessCode == command.ProcessCode)
                ?? throw new HandlerException(
                    $"Процесс с кодом {command.ProcessCode} не найден",
                    ErrorCodesEnum.Business);

            // 2) Генерим регистрационный номер (как в Start)
            var requestNumber = await helperService
                .GenerateRequestNumberAsync(command.ProcessCode, cancellationToken);

            // 3) Сериализуем payload
            var options = new JsonSerializerOptions { Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping };
            var payloadJson = JsonSerializer.Serialize(command.Payload, options);

            var regData        = payloadReader.ReadSection<RegData>(command.Payload, "regData");
            var processDataDto = payloadReader.ReadSection<ProcessDataDto>(command.Payload, "processData");

            // 4) СОЗДАЁМ ProcessData в статусе Draft (вместо Started)
            var processDataCreatedEvent = new ProcessDataCreatedEvent
            {
                ProcessId     = process.Id,
                ProcessCode   = process.ProcessCode,
                ProcessName   = process.ProcessName,
                RegNumber     = requestNumber,
                InitiatorCode = regData.UserCode,
                InitiatorName = regData.UserName,
                StatusCode    = "Draft",      // ВАЖНО
                StatusName    = "Черновик",   // ВАЖНО
                PayloadJson   = payloadJson,
                Title         = processDataDto.DocumentTitle
            };

            await unitOfWork.ProcessDataRepository
                .RaiseEvent(processDataCreatedEvent, cancellationToken);

            // 7) Возвращаем тот же ответ, что и Start (Guid + RegNumber)
            return new BaseResponseDto<StartProcessResponse>
            {
                Data = new StartProcessResponse
                {
                    ProcessGuid = processDataCreatedEvent.EntityId,
                    RegNumber   = requestNumber
                }
            };
        }
    }
}


